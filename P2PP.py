#!/usr/bin/pythonw

__author__ = "Tom Van den Eede"
__copyright__ = "Copyright 2018, Palette2 Splicer Post Processing Project"
__credits__ = ["Tom Van den Eede"]
__license__ = "GPL"
__version__ = "1.0.0"
__maintainer__ = "Tom Van den Eede"
__email__ = "P2PP@pandora.be"
__status__ = "Beta"


import struct
import sys
import os
import getopt



#########################################
# Variable default values
#########################################

DEBUG_MODE = False
DEBUG_MODE_INPUT_FILE = '/Users/tomvandeneede/Desktop/Lego.gcode'

graphicalUserInterface = True

# Filament Transition Table
FilamentUsed            = [ False , False , False , False ]
FilamentType            = [ "","","","" ]
FilamentName            = [ "Unnamed", "Unnamed" , "Unnamed", "Unnamed"]
FilamentColor           = [ "-" , "-" ,  "-" , "-" ]
DefaultAlgorithm        = "D000 D000 D000"
AlgorithmDict           =  {}
AlgorithmCount          = 0

ProcessWarnings = ""


# printerprofile is a unique ID linked to a printer configuration profile in the Palette 2 hardware.
PrinterProfile = ''


# list of possible algorithms
AlgorithmList = []

#final output array aith Gcode
OutputArray=[]

# spliceoffset allows for a correction of the position at which the transition occurs.   When the first transition is scheduled
# to occur at 120mm in GCode, you can add a number of mm to push the transition further in the purge tower.  This srves a similar
# function as the transition offset in chroma
SpliceOffset = 0.0


# these  varaibles are used to build the splice information table (Omega-30 commands in GCode) that will drive the Palette2
SpliceLocation = []
SpliceTool     = []
SpliceLength   = []


# ping text is a text variable to store information about the PINGS generated by P2PP.   this information is pasted after
# the splice information right after the Palette2 header
PingLocation   =[]

# Hotswapcount is the number of hotswaps generated furing the print.... not sure what this is used for, this variable is
# only used to complete the header
HotSwapCount   = 0


# TotalExtrusion keeps track of the total extrusion in mm for the print taking into account the Extruder Multiplier set
# in the GCode settings.
TotalExtrusion = 0

# The next 3 variables are used to generate pings.   A ping is scheduled every ping interval.  The LastPing option
# keeps the last extruder position where a ping was generated.  It is set to -100 to pring the first PING forward...
# Not sure this is a good idea.   Ping distance increases over the print in an exponential way.   Each ping is 1.03 times
# further from the previous one.   Pings occur in random places!!! as the are non-intrusive and don't causes pauses in the
# print they aren ot restricted to the wipe tower and they will occur as soon as the interval length for ping is exceeded.

LastPing = -100
PingInterval   = 350
PingExp        = 1.03


#currenttool/lastLocation are variables required to generate O30 splice info.   splice info is generated at the end of the tool path
# and not at the start hance the reauirement to keep the toolhead and lastlocation to perform the magic
currenttool    = -1
LastLocation = 0


# Capture layer inbformation for short splice texts
Layer = "No Layer Info"

#Extrusionmultiplier keeps track of M221 commands during the print.  Default is 0.95 as this is the default value in the
# prusa MK3 firmware.   You can change here if needed
extrusionMultiplier = 0.95

# provide extra filament at the end of the run
extraFilament = 150
minimalSpliceLength=80
minimalStartSpliceLenght=100

#toolchange is a variable that keeps track if the processed G-Code is part of a toolchange or a regular path
# it is set based on patterns used in the gcode
ToolChange = False
FilInfo = False


# HexifyShort is used to turn a short integer into the specific notation used by Mosaic
def HexifyShort(num):
    return "D" + '{0:04x}'.format(num)

# HexifyLong is used to turn a 32-bit integer into the specific notation used by Mosaic
def HexifyLong(num):
    return "D" + '{0:08x}'.format(num)

# HexifyFloat is used to turn a 32-but floating point number into the specific notation used by Mosaic
def HexifyFloat(f):
    return "D" + (hex(struct.unpack('<I', struct.pack('<f', f))[0]))[2:]

#################################################################
########################## COMPOSE WARNING BLOCK ################
#################################################################

def LogWarning( text ):
    global ProcessWarnings
    ProcessWarnings += text +"\n"

#################################################################
########################## ALIGORITHM PROCESSING ################
#################################################################

def CreateProfileString(heating, compression, cooling):
    return "{} {} {}".format(HexifyShort(int(heating)), HexifyShort(int(compression)), HexifyShort(int(cooling)))


def ProcessMaterial(SpliceInfo):
    global DefaultAlgorithm, AlgorithmDict

    fields = SpliceInfo.split("_")
    numfields = len(fields)

    if fields[0] == "DEFAULT" and numfields == 4:
        DefaultAlgorithm = CreateProfileString(fields[1], fields[2], fields[3])

    if numfields == 5:
        key = "{}-{}".format(fields[0], fields[1])
        AlgorithmDict[key] = CreateProfileString(fields[2], fields[3], fields[4])


def RetrieveAlgorithm(key):
    global ProcessWarnings
    try:
        return AlgorithmDict[key]
    except:
        LogWarning ("WARNING: No Algorithm defined for transitionin {}.  Using Default.".format(key))
        return DefaultAlgorithm

def Algorithms():
    global  AlgorithmList
    for i in range(4):
        for j in range(4):
            if (i==j) or not FilamentUsed[i] or not FilamentUsed[j]:
                continue
            key = "{}-{}".format(FilamentType[i], FilamentType[j])
            AlgorithmList.append("D{}{} {}".format(i+1,j+1,RetrieveAlgorithm(key)))



#############################################################################
## Generate O30 Commands for color switches
#############################################################################

def SwitchColor( newTool , Location):
    global currenttool, LastLocation
    global SpliceOffset, FilamentUsed, Layer
    global SpliceLocation, SpliceTool, SpliceLength

    # some commands are generated at the end to unload filament, they appear as a reload of current filament - messing up things
    if newTool == currenttool:
        return

    Location += SpliceOffset


    if (newTool == -1):
        Location += extraFilament
    else:
        FilamentUsed[newTool] = True

    Length = Location - LastLocation

    if (currenttool != -1):
        SpliceLocation.append(Location)
        SpliceLength.append(Length)
        SpliceTool.append(currenttool)

        if len(SpliceLocation)==1:
            if SpliceLength[0] < minimalStartSpliceLenght:
                LogWarning(";Warning : Short first splice (<{}mm) Length:{}\n".format(Length, minimalStartSpliceLenght))
        else:
            if SpliceLength[-1] < minimalSpliceLength:
                LogWarning(";Warning: Short splice (<{}mm) Length:{} Layer:{} Tool:{}\n".format(minimalSpliceLength, Length, Layer, currenttool))

    LastLocation = Location
    currenttool = newTool



# keep track of the filaments that are used throughout the print.
# This information is stored in the header of the file
def FilamentUsage():
    result = "O25 "
    # all filament is type 1 for now, need to work on including type info in Slic3r
    for i in range(4):
        if FilamentUsed[i]:
            if FilamentType[i]=="":
                LogWarning("Filament #{} is missing Material Type, make sure to add ;P2PP FT=[filament_type] to filament GCode".format(i))
            if FilamentName[i]=="Unnamed":
                LogWarning("Filament #{} is missing Name, make sure to add ;P2PP FN=[filament_preset] to filament GCode".format(i))
            if FilamentName[i]=="-":
                LogWarning("Filament #{} is missing Color info, make sure to add ;P2PP FC=[extruder_colour] to filament GCode".format(i))
                FilamentName[i]='000000'
            result +="D{}{}{} ".format(i+1, FilamentColor[i],FilamentName[i])
        else:

         result += "D0 "
    return result+"\n"

# Generate the Omega - Header that drives the plette 2 to generate filament

def OmegaHeader(Name):
    global SpliceOffset

    if PrinterProfile == '':
        LogWarning("Printerprofile identifier is missing, add ;P2PP PRINTERPROFILE=<your printer profile ID> to the Printer Start GCode block")
    if len(SpliceLocation) == 0:
        LogWarning("This does not look lie a multi color file......")

    Algorithms()

    header = []
    header.append('O21 ' + HexifyShort(20)+"\n")  # MSF2.0
    header.append('O22 D' + PrinterProfile+"\n")  # printerprofile used in Palette2
    header.append('O23 D0001'+"\n" )              # unused
    header.append('O24 D0000'+"\n" )              # unused

    header.append(FilamentUsage())

    header.append('O26 ' + HexifyShort(len(SpliceLocation))+"\n")
    header.append('O27 ' + HexifyShort(len(PingLocation))+"\n")
    header.append('O28 ' + HexifyShort(len(AlgorithmList))+"\n")
    header.append('O29 ' + HexifyShort(HotSwapCount)+"\n")

    for i in range(len(SpliceLocation)):
        header.append("O30 D{:0>1d} {}\n".format(SpliceTool[i],HexifyFloat(SpliceLocation[i])))

    for i in range(len(AlgorithmList)):
        header.append ("O32 {}\n".format(AlgorithmList[i]))

    if len(SpliceLocation)>0:
        header.append("O1 D{} {}\n".format(Name, HexifyFloat(SpliceLocation[-1])))
    else:
        header.append("O1 D{} {}\n".format(Name,HexifyFloat(TotalExtrusion+SpliceOffset)))
    header.append("M0\n")
    header.append("T0\n")

    header.append(";------------------:"+"\n")
    header.append(";SPLICE INFORMATION:"+"\n")
    header.append(";------------------:"+"\n")
    header.append("\n;       Splice Offset = {:-8.2f}mm\n\n".format(SpliceOffset))

    for i in range(len(SpliceLocation)):
        header.append(";{:04}   Tool: {}  Location: {:-8.2f}mm   length {:-8.2f}mm \n".format(i+1, SpliceTool[i],SpliceLocation[i], SpliceLength[i]))

    header.append("\n\n\n;------------------:"+"\n")
    header.append(";PING  INFORMATION:"+"\n")
    header.append(";------------------:"+"\n")

    for i in range(len(PingLocation)):
        header.append("Ping {:04} at {:-8.2f}mm\n".format(i+1,PingLocation[i]))



    header.append("\n\n\n;------------------:"+"\n")
    header.append(";PROCESS WARNINGS:"+"\n")
    header.append(";------------------:"+"\n")

    if ProcessWarnings=="":
            header.append("None")
    else:
            header.append(ProcessWarnings)
    return header

    header.append("\n\n\n;Processed by P2PP version {}\n\n\n".format(__version__))


#Gcode remove speed information from a G1 statement
def gcodeRemoveSpeed(gcode):
    result=""
    parts = gcode.strip("\n").split(" ")

    for subcommand in parts:
        if subcommand=="":
            continue
        if subcommand[0]!="F":
            result += subcommand+" "

    if len(result)<4:
        return ";P2PP Removed "+gcode

    return result+"\n"



# G Code parsing routine
def ParseGCodeLine(gcodeFullLine):
    global TotalExtrusion,extrusionMultiplier, Layer, PrinterProfile
    global LastPing, PingExp, PingInterval
    global ToolChange, CurrentTool, ToolChange, FilInfo
    global SpliceOffset, minimalStartSpliceLenght, minimalSpliceLength, OutputArray

    if len(gcodeFullLine)<2:
        return gcodeFullLine

    gcodeCommand2 = gcodeFullLine[0:2]
    gcodeCommand4 = gcodeFullLine[0:4]


    # Processing of extrusion multiplier commands
    #############################################
    if gcodeCommand4=="M221":
        for part in gcodeFullLine.split(" "):
            if(part==""):
                continue
            if part[0] == 'S':
                extrusionMultiplier = float(part[1:])/100

    # Processing of Extruder Movement commands
    # and generating ping at thereshold intervals
    #############################################
    if gcodeCommand2 == "G1":
        for part in gcodeFullLine.split(" "):
            if (part==""):
                continue
            if part[0] == 'E':
                offsetE = part[1:]

                TotalExtrusion += float(offsetE) * extrusionMultiplier

                if (TotalExtrusion - LastPing) > PingInterval:
                    PingInterval = PingInterval * PingExp

                    if PingInterval >1000:
                        PingInterval = 1000
                    LastPing = TotalExtrusion
                    PingLocation.append(LastPing)
                    OutputArray.append(";Palette 2 - PING\nG4 S0\nO31 "+HexifyFloat(LastPing))
                    OutputArray.append("M117 PING {:03} {:-8.2f}mm\n\n".format(len(PingLocation) , LastPing))



    # Process Toolchanges. Build up the O30 table with Splice info
    ##############################################################
    if gcodeFullLine[0] == 'T':
        newTool = int(gcodeFullLine[1])
        SwitchColor( newTool  , TotalExtrusion)
        FilInfo = True
        return ";P2PP removed "+gcodeFullLine

    # Build up the O32 table with Algo info
    #######################################
    if gcodeFullLine.startswith(";P2PP FT=") and FilInfo :  #filament type information
        FilamentType[currenttool] = gcodeFullLine[9:].rstrip("\n")



    if gcodeFullLine.startswith(";P2PP FN=") and FilInfo :  #filament color information
        p2ppinfo = gcodeFullLine[9:].strip("\n-+!@#$%^&*(){}[];:\"\',.<>/?").replace(" ", "_")
        FilamentName[currenttool] = p2ppinfo

    if gcodeFullLine.startswith(";P2PP FC=#") and FilInfo :  #filament color information
        p2ppinfo = gcodeFullLine[10:].rstrip("\n")
        FilamentColor[currenttool] = p2ppinfo



    # Other configuration information
    # this information should be defined in your Slic3r printer settings, startup GCode
    ###################################################################################
    if gcodeFullLine.startswith(";P2PP PRINTERPROFILE=") and PrinterProfile=='':   # -p takes precedence over printer defined in file
        PrinterProfile = gcodeFullLine[21:].rstrip("\n")
    if gcodeFullLine.startswith(";P2PP SPLICEOFFSET="):
        SpliceOffset = float(gcodeFullLine[19:].rstrip("\n"))
    if gcodeFullLine.startswith(";P2PP MINSTARTSPLICE="):
        minimalStartSpliceLenght = float(gcodeFullLine[21:].rstrip("\n"))
        if minimalStartSpliceLenght<100:
            minimalStartSpliceLenght=100
    if gcodeFullLine.startswith(";P2PP MINSPLICE="):
        minimalSpliceLength = float(gcodeFullLine[16:].rstrip("\n"))
        if (minimalSpliceLength<40):
            minimalSpliceLength = 40
    if gcodeFullLine.startswith(";P2PP MATERIAL_"):
        ProcessMaterial(gcodeFullLine[15:].rstrip("\n"))

    # Next section(s) clean up the GCode generated for the MMU
    # specially the rather violent unload/reload reauired for the MMU2
    ###################################################################
    if "TOOLCHANGE START" in gcodeFullLine:
        FilInfo = False
        ToolChange = True
    if "TOOLCHANGE END" in gcodeFullLine:
        ToolChange = False
    if "TOOLCHANGE UNLOAD" in gcodeFullLine:
        OutputArray.append(";P2PP Set Wipe SPeed\nG1 F2000\n")

    #--------------------------------------------------------------
    # Do not perform this part of the GCode for MMU filament unload
    #--------------------------------------------------------------
    DiscardedMoves = ["E-15.0000" , "G1 E10.5000" , "G1 E3.0000" , "G1 E1.5000"]
    if ToolChange:
        if gcodeCommand2=="G1":
            for filter in DiscardedMoves:
                if filter in gcodeFullLine:
                    return ";P2PP removed "+gcodeFullLine
            return gcodeRemoveSpeed(gcodeFullLine)
        if gcodeCommand4=="M907":
            return ";P2PP removed "+gcodeFullLine
        if gcodeFullLine.startswith("G4 S0"):
            return ";P2PP removed "+gcodeFullLine


    # Layer Information
    if gcodeFullLine.startswith(";LAYER "):
        Layer = gcodeFullLine[7:].strip("\n")
    # return the original line if no change required
    ################################################
    return gcodeFullLine


#########################################################
#################### MAIN ROUTINE #######################
#########################################################
def main(argv):
    global SpliceOffset, PrinterProfile, graphicalUserInterface, OutputArray
    fname = ""
    _taskName = "NoName"

    try:
        opts, args = getopt.getopt( argv, "gci:o:p:")
    except getopt.GetoptError:
        sys.exit(2)
    for opt, arg in opts:
        if opt == "-g":
            ##################
            #do gui stuff here
            ##################
            graphicalUserInterface = True
        if opt == "-i":
            fname = arg
            basename = os.path.basename(fname)
            _taskName = os.path.splitext(basename)[0]

        if opt == '-o':
            SpliceOffset = float(arg)
        if opt == '-p':
            PrinterProfile = arg

    # for debugging purposes only - this allows running the tool outside of slicer
    if DEBUG_MODE:
        fname = DEBUG_MODE_INPUT_FILE

    #read the input file
    ####################
    with open(fname) as opf:
        gcode = opf.readlines()
    opf.close

    # Process the file
    ##################
    for line in gcode:
      OutputArray.append(ParseGCodeLine(line))
    SwitchColor( -1 , TotalExtrusion)
    header=OmegaHeader(_taskName)

    #write the output file
    ######################
    opf = open( fname , "w")
    opf.writelines(header)
    opf.writelines(OutputArray)

if __name__ == "__main__":
    main(sys.argv[1:])